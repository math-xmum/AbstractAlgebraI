msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Thu Apr  3 17:26:25 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! ğŸ‰"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ğŸ­"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ğŸ‰"
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "Rfl tactic"
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "This level gets you familiar with the game interface."
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "The equality can be settaled by evaluation."
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "You can use either `rfl` or `norm_num`."
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "rfl and norm_num are very handy to close obvious goals."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "Rewrite"
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "This level gets you familiar with the game interface."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You can use rw [h] to rewrite `x` by `2`."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You can either start using `Â«{h}Â»` or `Â«{g}Â»`."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You should use `Â«{h}Â»` now."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You should use `Â«{g}Â»` now."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "rw is the most basic command you can use."
msgstr ""

#: Game.Levels.BasicLean
msgid "Basic Lean"
msgstr ""

#: Game.Levels.BasicLean
msgid "We start with some basic Lean tactics."
msgstr ""

#: Game.Levels.BasicGroupTheory.L01_identity
msgid "Suppose $G$ is a set with a binary operation $*$.\n"
"\n"
"The following statement claims that identity element is unique.\n"
"\n"
"Suppose $e$ and $e'$ are two identity elements, we need to prove $e=e'$."
msgstr ""

#: Game.Levels.BasicGroupTheory.L01_identity
msgid "Use `h1`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L01_identity
msgid "Use `h4`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L02_assoc
msgid "A semi-group is a set $G$ with a binary operation $*$ such that $*$ has associative law."
msgstr ""

#: Game.Levels.BasicGroupTheory.L02_assoc
msgid "Use `group`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "A  monoid is a semi-group with identity and .\n"
"\n"
"A  group is a monoid such that every element has inverse."
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Use `aâ»Â¹`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Also can use And.intro to split the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Use `group`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Use `group`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Note that if inverse exits, then it is unique."
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `mul_one`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `leftinvc`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `assoc`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `rightinvb`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `one_mul`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L05_Subgroup_def
msgid "A subgroup of a group $G$ is a nonempty subset $H$ of $G$ such that $*$ is closed under $H$ and inverse.\n"
"\n"
"We have a criterion for a set H to be a subgroup of $G$:\n"
"If H is non-empty and a âˆˆ  H âˆ§ b âˆˆ  H implies a * bâ»Â¹ âˆˆ H\n"
"then H is a subgroup of G\n"
"\n"
"The follow theorem show that,"
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "For example, â„¤ is a group under addition.\n"
"Now the set of even integers, 2â„¤ := {2n | n âˆˆ â„¤ }, is a subgroup of â„¤.\n"
"More generally, kâ„¤ := {k*n | n âˆˆ â„¤ } is also a subgroup of â„¤.\n"
"Morover, all subgoup of â„¤ is of the form kâ„¤ for some k âˆˆ â„•.\n"
"\n"
"In fact, â„• â†’ {subgroup of â„¤} given by k â†¦ kâ„¤ is a bijection."
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "Intro all elements"
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "Use Int.sub_emod"
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "Use hypothesis to simp the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Let Z_n be the set of integers modulo $n$.\n"
"Then Z_n form a commutative group (i.e. an Abelian group)."
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use the definition to simplify the goal.\n"
"You can use `simp [add]'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `ext' tactic"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `simp' to simplify the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `add_assoc'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use the definition of neg"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `add_comm'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "A `â…a,bâ†:=a * b * aâ»Â¹ * bâ»Â¹' is called the commutator of $a$ and $b$.\n"
"\n"
"A group is abelian if all commutators are one."
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Use `constructor' to split the goal into two parts"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "replace `a * b'  by `b * a' using the hypothesis"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "apply `mul_right_cancel' twice to translate the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Rewrite the left hand side using the hypothesis"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "If $G$ is a group such that $a * a = 1$ for all $a in G$, then $G$ is abelian."
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use `mul_right_cancel' to translate the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use the hypothesis"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use Â«{inv_eq_self}Â» smartly"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "You can use `nth_rw' to specify the location of the term to rewrite"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Let H be a subgroup of G.\n"
"The subset g â€¢ H := {gh | hâˆˆH} for some gâˆˆG is called a left coset of H.\n"
"\n"
"We first prove the simple fact that\n"
"x âˆˆ g â€¢ H â†” gâ»Â¹ * x âˆˆ H\n"
"\n"
"The above lemma is called `mem_leftCoset_iff' in Mathlib."
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Note that x âˆˆ g â€¢ H means âˆƒ h: G,  h âˆˆ H âˆ§  g * h = x. Use `obtain' to obtain the anxiety element h.\n"
"For example, one can use\n"
"`obtain âŸ¨h, hh1,hh2âŸ© := h1'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Use `simp' to clear up Â«{hh2}Â»"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Rewrite using Â«{hh2}Â»"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "The goal can be cleared by `simp'/`group' and `assumption'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Intro the assumption."
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Use `gâ»Â¹ * x'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "The goal can be cleared by `simp'/`group' and `assumption'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Let H be a subgroup of G.\n"
"The subset g â€¢ H := {gh | hâˆˆH} for some gâˆˆG is called a left coset of H.\n"
"\n"
"Basically all cosets are essentially the same in the sense that there is a natural bijection between g H and k H for arbitrary g k âˆˆ G.\n"
"\n"
"In Lean, a bijection between two types Î± and Î² is represented by the type `Equiv Î± Î²'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Use `constructor' to expend the definition of Equiv"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Pick the 3rd goal, which required to define a map from g â€¢ H to k â€¢ H using `pick_goal 3'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Define the map g â€¢ H âˆ‹ x â†¦ (k * gâ»Â¹)*x. On can achive this by using `use fun x => âŸ¨(k * gâ»Â¹)*x, ?_âŸ©'\n"
"Here we need to prove that the function is well defined, i.e.  `(k * gâ»Â¹)*x âˆˆ k â€¢ H'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "x âˆˆ g â€¢ H means âˆƒ h âˆˆ H, g â€¢ h = x"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "One can clear up the expression in Â«{hh}Â» by `simp at Â«{hh}Â»'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "To show k * gâ»Â¹ * â†‘x âˆˆ k â€¢ H, one should provide an element a in h such that k gâ»Â¹ x  = k a. Ore one can try to replace x by g*h first and simplify the expression using `group'."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Now `use h'."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Now construct the inverse function by  `pick_goal 3'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "This is the same as the first case. We let you to practice by yourself."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Now `use h'."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "`Function.LeftInverse g f' means âˆ€ x, g (f x) = x. So we use `intro' to reveal the goal."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Since `x' is a subtype, `y = x' if and only if the `y.1 = x.1'. Use `ext' to reduced the problem to comparing the values hold in  y and x."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Use `simp' to clear up the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Use `group' to finish the proof."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "This is similar to the pervious case."
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Let H be a subgroup of G.\n"
"Then g â€¢ H = k â€¢ H if and only if kâ»Â¹ * g âˆˆ H.\n"
"\n"
"We now prove only if part of this statement first."
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Note that g âˆˆ g â€¢ H."
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Use 1"
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "By definition 1 is certainly in H, but you still need to explicitly point it out using `Subgroup.one_mem'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Now use Â«{h1}Â» by rewrite the right hand side of Â«{hg}Â» (rw [Â«{h1}Â»] at Â«{hg}Â»)"
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Apply `mem_leftCoset_iff' and the rest is trivial."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Let H be a subgroup of G.\n"
"\n"
"Every left coset g â€¢ H is an H-orbit under the right translation action:\n"
"Let x âˆˆ g â€¢ H. If y is also in g â€¢ H, then there is an element h âˆˆ H such that x * h = y.  Since `h = xâ»Â¹ * y`, it means `xâ»Â¹ * y âˆˆ H`.\n"
"The reverse direction is also true.\n"
"We now prove this.\n"
"\n"
"Later we call this\n"
"`Subgroup.mem_coset_iff_diff_mem_subgroup`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Use `constructor` to split the goals."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Use `mem_leftCoset_iff` to translate\n"
"x âˆˆ g â€¢ H into gâ»Â¹ x âˆˆ H."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Note that xâ»Â¹ * y = (gâ»Â¹ * x)â»Â¹ * (gâ»Â¹ * y).\n"
"You can use `have\n"
"have hxy :xâ»Â¹ * y = (gâ»Â¹ * x)â»Â¹ * (gâ»Â¹ * y) := by group` to establish this claim."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Use Â«{hxy}Â» to rewrite the goal."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "If `a âˆˆ H`, `b âˆˆ H`, then `aâ»Â¹ * b âˆˆ H`. This is Subgroup.mem_of_inv_mul_mem"
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Since x âˆˆ g â€¢ H, we have gâ»Â¹ x âˆˆ H.\n"
"Therefore, that `y = x * (xâ»Â¹ * y) = g * ((gâ»Â¹ * x) * (xâ»Â¹ * y)) ` for some hâˆˆH."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "We start to execute the above argument with `intro hxy`."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Now use `mem_leftCoset_iff` to translate Â«{hx}Â» into gâ»Â¹ * x âˆˆ H."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Now use ((gâ»Â¹*x) * (xâ»Â¹ *y)) to closed the goal."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "Use `constructor` to split the Goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "This follows from `Subgroup.mul_mem`, Â«{hxy}Â» and Â«{hgx}Â»."
msgstr ""

#: Game.Levels.BasicGroupTheory.L13_Coset_transitive
msgid "This is follows from the group law. Consider to use `group` and `simp` tactic to clear up the goal."
msgstr ""

#: Game.Levels.BasicGroupTheory.L14_Coset_disjoint
msgid "Let H be a subgroup of G.\n"
"For two cosets g â€¢ H and k â€¢ H, either\n"
"g â€¢ H âˆ© k â€¢ H = âˆ…  or g â€¢ H = k â€¢ H.\n"
"Moreover, g â€¢ H = k â€¢ H if and only if kâ»Â¹ * g âˆˆ H.\n"
"\n"
"We now prove these statements"
msgstr ""

#: Game.Levels.BasicGroupTheory.L14_Coset_disjoint
msgid "By classical logic, P âˆ¨ Q is equivalent to Â¬ P â†’ Q.\n"
"Rewrite using `Classical.or_iff_not_imp_left` to translate the goal into Â¬ P â†’ Q."
msgstr ""

#: Game.Levels.BasicGroupTheory.L14_Coset_disjoint
msgid "Now introduce a hypothesis `hypo : Â¬ (g â€¢ H :Set G) = (k â€¢ H : Set G)`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L14_Coset_disjoint
msgid "By `Subgroup.mem_coset_iff_diff_mem_subgroup`, z âˆˆ g â€¢ H â†” zâ»Â¹ * x âˆˆ H. One can use rewrite to replace z âˆˆ g â€¢ H with zâ»Â¹ * x âˆˆ H."
msgstr ""

#: Game.Levels.BasicGroupTheory.L14_Coset_disjoint
msgid "Do the same thing for z âˆˆ k â€¢ H. If you use `rw` The goal is automatically closed since `rw` all rewrite the goal and then apply `rfl`. If you wish to prevent this, you can use the tactic `rewrite` instead."
msgstr ""

#: Game.Levels.BasicGroupTheory
msgid "Basic Group Theory"
msgstr ""

#: Game.Levels.BasicGroupTheory
msgid "We now learn some basic Group Theory."
msgstr ""

#: Game
msgid "Abstract Algebra Game"
msgstr ""

#: Game
msgid "Welcome to the abstract algebra game!"
msgstr ""

#: Game
msgid "We plan to cover basic group theory, ring theory and Galois theory."
msgstr ""

#: Game
msgid "Abstract Algebra Game"
msgstr ""

#: Game
msgid "Abstract Algebra Game for MAT205 Xiamen University Malaysia."
msgstr ""
